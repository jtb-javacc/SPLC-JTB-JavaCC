/* Generated by JTB 1.4.11 */


/* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
CL_Option	JTB_Option	Description
-cl 		JTB_CL=(true|false)	Print a list of the classes generated to standard out
-d dir 		JTB_D="dir" 	Short for (and overwrites) "-nd dir/syntaxtree -vd dir/visitor"
-dl 		JTB_DL=(true|false)	Generate depth level info
-e 			JTB_E=(true|false) 	Suppress JTB semantic error checking
-f 			JTB_F=(true|false) 	Use descriptive node class field names
-h 			N/A 	Display this help message and quit
-ia 		JTB_IA=(true|false)	Inline visitors accept methods on base classes
-jd 		JTB_JD=(true|false)	Generate JavaDoc-friendly comments in the nodes and visitor
-nd dir 	JTB_ND="dir" 	Use dir as the package for the syntax tree nodes
-np pkg 	JTB_NP="pkg" 	Use pkg as the package for the syntax tree nodes
-ns class	JTB_NS="class" 	Use class as the class which all node classes will extend
-o file 	JTB_o="file" 	Use file as the filename for the annotated output grammar
-p pkg 		JTB_P="pkg" 	Short for (and overwrites) "-np pkg.syntaxtree -vp pkg.visitor"
-pp 		JTB_PP=(true|false)	Generate parent pointers in all node classes
-printer 	JTB_PRINTER 	Generate a syntax tree dumping visitor
-si 		N/A 	Read from standard input rather than a file
-scheme 	JTB_SCHEME 	Generate Scheme records representing the grammar and a Scheme tree building visitor
-tk 		JTB_TK=(true|false)	Generate special tokens into the tree
-vd dir 	JTB_VD="dir" 	Use dir as the package for the default visitor classes
-vp pkg 	JTB_VP="pkg" 	Use pkg as the package for the default visitor classes
-w 			JTB_W=(true|false )	Do not overwrite existing files
 */
options
{
  STATIC = true;
  OUTPUT_LANGUAGE = "c++";
  OUTPUT_DIRECTORY = "../jcc";
  //  TOKEN_MANAGER_SUPER_CLASS = "MyTm";  //  TOKEN_MANAGER_INCLUDES = "mytm.h";
  PARSER_INCLUDES = "ASTdcl.h";
  //  PARSER_SUPER_CLASS = "MyParser";  //  TOKEN_EXTENDS = "TokenBase";  //  TOKEN_INCLUDES = "token_base.h";
  // JTB_D = "../ast";
  // JTB_PP = true;
  // JTB_VA = true;
  // JTB_PRINTER = true;
  //  JTB_JD=true;
  //  JTB_NP="CST";  //  JTB_VP="VST";
  NAMESPACE = "SPL";
}

PARSER_BEGIN(Parser)

//template AST::CompilationUnit<Value*, int>* Parser::CompilationUnit<Value*, int>();
PARSER_END(Parser)

SKIP :
/* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
/* Types */
{
  < INT : "int" >
| < BOOL : "boolean" >
}

TOKEN :
/* LITERALS */
{
  < INTEGER_LITERAL : ( <DIGIT> )+ >
}

/*
 * Program structuring syntax follows.
 */
/** Compilation unit. */
template<typename R, typename ... A>
AST::CompilationUnit<R, A...>* CompilationUnit() :
{
  // --- JTB generated node declarations ---
  AST::NodeListOptional<R, A...>* n0 = new AST::NodeListOptional<R, A...>();
  AST::NodeChoice<R, A...>* n1 = null;
  AST::NodeSequence<R, A...>* n2 = null;
  AST::VarDeclaration<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
  AST::Statement<R, A...>* n6 = null;
  AST::NodeToken<R, A...>* n7 = null;
  Token* n8 = null;
  // --- user BNFProduction java block ---
  String name;
}
{
  (
    (
      { n2 = new AST::NodeSequence<R, A...>(2); }
      n3 =  VarDeclaration<R, A...>()
      { n2->addNode(n3); }
      n5 = ";"
      { n4 = makeNodeToken<R, A...>(n5); }
      { n2->addNode(n4); }
      { n1 = new AST::NodeChoice<R, A...>(n2, 0, 2); }
    |
      n6 =  Statement<R, A...>()
      { n1 = new AST::NodeChoice<R, A...>(n6, 1, 2); }
    )
    { n0->addNode(n1); }
  )*
  n8 = < EOF >
  {
    n8->beginColumn++;
    n8->endColumn++;
    { n7 = makeNodeToken<R, A...>(n8); }
  }
  { return new AST::CompilationUnit<R, A...>(n0, n7); }
}

/** Variable declaration. */
template<typename R, typename ... A>
AST::VarDeclaration<R, A...>* VarDeclaration() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::NodeToken<R, A...>* n1 = null;
  Token* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
  AST::NodeToken<R, A...>* n5 = null;
  Token* n6 = null;
}
{
  (
    (
      n2 = "boolean"
      { n1 = makeNodeToken<R, A...>(n2); }
      { n0 = new AST::NodeChoice<R, A...>(n1, 0, 2); }
    |
      n4 = "int"
      { n3 = makeNodeToken<R, A...>(n4); }
      { n0 = new AST::NodeChoice<R, A...>(n3, 1, 2); }
    )
    
  )
  n6 = < IDENTIFIER >
  { n5 = makeNodeToken<R, A...>(n6); }
  { return new AST::VarDeclaration<R, A...>(n0, n5); }
}

/*
 * Expression syntax follows.
 */
/** Expression. */
template<typename R, typename ... A>
AST::Expression<R, A...>* Expression() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::Assignment<R, A...>* n1 = null;
  AST::ConditionalOrExpression<R, A...>* n2 = null;
}
{
  (
    LOOKAHEAD( PrimaryExpression() "=" )
    n1 =  Assignment<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 2); }
  |
    n2 =  ConditionalOrExpression<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n2, 1, 2); }
  )
  { return new AST::Expression<R, A...>(n0); }
}

/** Assignment. */
template<typename R, typename ... A>
AST::Assignment<R, A...>* Assignment() :
{
  // --- JTB generated node declarations ---
  AST::PrimaryExpression<R, A...>* n0 = null;
  AST::NodeToken<R, A...>* n1 = null;
  Token* n2 = null;
  AST::Expression<R, A...>* n3 = null;
}
{
  n0 =  PrimaryExpression<R, A...>()
  n2 = "="
  { n1 = makeNodeToken<R, A...>(n2); }
  n3 =  Expression<R, A...>()
  { return new AST::Assignment<R, A...>(n0, n1, n3); }
}

/** Conditional or expression. */
template<typename R, typename ... A>
AST::ConditionalOrExpression<R, A...>* ConditionalOrExpression() :
{
  // --- JTB generated node declarations ---
  AST::ConditionalAndExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeSequence<R, A...>* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
  AST::ConditionalAndExpression<R, A...>* n5 = null;
}
{
  n0 =  ConditionalAndExpression<R, A...>()
  (
    { n2 = new AST::NodeSequence<R, A...>(2); }
    n4 = "||"
    { n3 = makeNodeToken<R, A...>(n4); }
    { n2->addNode(n3); }
    n5 =  ConditionalAndExpression<R, A...>()
    { n2->addNode(n5); }
    { n1->addNode(n2); }
  )*
  { return new AST::ConditionalOrExpression<R, A...>(n0, n1); }
}

/** Conditional and expression. */
template<typename R, typename ... A>
AST::ConditionalAndExpression<R, A...>* ConditionalAndExpression() :
{
  // --- JTB generated node declarations ---
  AST::InclusiveOrExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeSequence<R, A...>* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
  AST::InclusiveOrExpression<R, A...>* n5 = null;
}
{
  n0 =  InclusiveOrExpression<R, A...>()
  (
    { n2 = new AST::NodeSequence<R, A...>(2); }
    n4 = "&&"
    { n3 = makeNodeToken<R, A...>(n4); }
    { n2->addNode(n3); }
    n5 =  InclusiveOrExpression<R, A...>()
    { n2->addNode(n5); }
    { n1->addNode(n2); }
  )*
  { return new AST::ConditionalAndExpression<R, A...>(n0, n1); }
}

/** Inclusive or expression. */
template<typename R, typename ... A>
AST::InclusiveOrExpression<R, A...>* InclusiveOrExpression() :
{
  // --- JTB generated node declarations ---
  AST::ExclusiveOrExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeSequence<R, A...>* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
  AST::ExclusiveOrExpression<R, A...>* n5 = null;
}
{
  n0 =  ExclusiveOrExpression<R, A...>()
  (
    { n2 = new AST::NodeSequence<R, A...>(2); }
    n4 = "|"
    { n3 = makeNodeToken<R, A...>(n4); }
    { n2->addNode(n3); }
    n5 =  ExclusiveOrExpression<R, A...>()
    { n2->addNode(n5); }
    { n1->addNode(n2); }
  )*
  { return new AST::InclusiveOrExpression<R, A...>(n0, n1); }
}

/** Exclusive or expression. */
template<typename R, typename ... A>
AST::ExclusiveOrExpression<R, A...>* ExclusiveOrExpression() :
{
  // --- JTB generated node declarations ---
  AST::AndExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeSequence<R, A...>* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
  AST::AndExpression<R, A...>* n5 = null;
}
{
  n0 =  AndExpression<R, A...>()
  (
    { n2 = new AST::NodeSequence<R, A...>(2); }
    n4 = "^"
    { n3 = makeNodeToken<R, A...>(n4); }
    { n2->addNode(n3); }
    n5 =  AndExpression<R, A...>()
    { n2->addNode(n5); }
    { n1->addNode(n2); }
  )*
  { return new AST::ExclusiveOrExpression<R, A...>(n0, n1); }
}

/** And expression. */
template<typename R, typename ... A>
AST::AndExpression<R, A...>* AndExpression() :
{
  // --- JTB generated node declarations ---
  AST::EqualityExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeSequence<R, A...>* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
  AST::EqualityExpression<R, A...>* n5 = null;
}
{
  n0 =  EqualityExpression<R, A...>()
  (
    { n2 = new AST::NodeSequence<R, A...>(2); }
    n4 = "&"
    { n3 = makeNodeToken<R, A...>(n4); }
    { n2->addNode(n3); }
    n5 =  EqualityExpression<R, A...>()
    { n2->addNode(n5); }
    { n1->addNode(n2); }
  )*
  { return new AST::AndExpression<R, A...>(n0, n1); }
}

/** Equality expression. */
template<typename R, typename ... A>
AST::EqualityExpression<R, A...>* EqualityExpression() :
{
  // --- JTB generated node declarations ---
  AST::RelationalExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeChoice<R, A...>* n2 = null;
  AST::NodeSequence<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
  AST::RelationalExpression<R, A...>* n6 = null;
  AST::NodeSequence<R, A...>* n7 = null;
  AST::NodeToken<R, A...>* n8 = null;
  Token* n9 = null;
  AST::RelationalExpression<R, A...>* n10 = null;
}
{
  n0 =  RelationalExpression<R, A...>()
  (
    (
      { n3 = new AST::NodeSequence<R, A...>(2); }
      n5 = "=="
      { n4 = makeNodeToken<R, A...>(n5); }
      { n3->addNode(n4); }
      n6 =  RelationalExpression<R, A...>()
      { n3->addNode(n6); }
      { n2 = new AST::NodeChoice<R, A...>(n3, 0, 2); }
    |
      { n7 = new AST::NodeSequence<R, A...>(2); }
      n9 = "!="
      { n8 = makeNodeToken<R, A...>(n9); }
      { n7->addNode(n8); }
      n10 =  RelationalExpression<R, A...>()
      { n7->addNode(n10); }
      { n2 = new AST::NodeChoice<R, A...>(n7, 1, 2); }
    )
    { n1->addNode(n2); }
  )*
  { return new AST::EqualityExpression<R, A...>(n0, n1); }
}

/** Relational expression. */
template<typename R, typename ... A>
AST::RelationalExpression<R, A...>* RelationalExpression() :
{
  // --- JTB generated node declarations ---
  AST::AdditiveExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeChoice<R, A...>* n2 = null;
  AST::NodeSequence<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
  AST::AdditiveExpression<R, A...>* n6 = null;
  AST::NodeSequence<R, A...>* n7 = null;
  AST::NodeToken<R, A...>* n8 = null;
  Token* n9 = null;
  AST::AdditiveExpression<R, A...>* n10 = null;
  AST::NodeSequence<R, A...>* n11 = null;
  AST::NodeToken<R, A...>* n12 = null;
  Token* n13 = null;
  AST::AdditiveExpression<R, A...>* n14 = null;
  AST::NodeSequence<R, A...>* n15 = null;
  AST::NodeToken<R, A...>* n16 = null;
  Token* n17 = null;
  AST::AdditiveExpression<R, A...>* n18 = null;
}
{
  n0 =  AdditiveExpression<R, A...>()
  (
    (
      { n3 = new AST::NodeSequence<R, A...>(2); }
      n5 = "<"
      { n4 = makeNodeToken<R, A...>(n5); }
      { n3->addNode(n4); }
      n6 =  AdditiveExpression<R, A...>()
      { n3->addNode(n6); }
      { n2 = new AST::NodeChoice<R, A...>(n3, 0, 4); }
    |
      { n7 = new AST::NodeSequence<R, A...>(2); }
      n9 = ">"
      { n8 = makeNodeToken<R, A...>(n9); }
      { n7->addNode(n8); }
      n10 =  AdditiveExpression<R, A...>()
      { n7->addNode(n10); }
      { n2 = new AST::NodeChoice<R, A...>(n7, 1, 4); }
    |
      { n11 = new AST::NodeSequence<R, A...>(2); }
      n13 = "<="
      { n12 = makeNodeToken<R, A...>(n13); }
      { n11->addNode(n12); }
      n14 =  AdditiveExpression<R, A...>()
      { n11->addNode(n14); }
      { n2 = new AST::NodeChoice<R, A...>(n11, 2, 4); }
    |
      { n15 = new AST::NodeSequence<R, A...>(2); }
      n17 = ">="
      { n16 = makeNodeToken<R, A...>(n17); }
      { n15->addNode(n16); }
      n18 =  AdditiveExpression<R, A...>()
      { n15->addNode(n18); }
      { n2 = new AST::NodeChoice<R, A...>(n15, 3, 4); }
    )
    { n1->addNode(n2); }
  )*
  { return new AST::RelationalExpression<R, A...>(n0, n1); }
}

/** Additive expression. */
template<typename R, typename ... A>
AST::AdditiveExpression<R, A...>* AdditiveExpression() :
{
  // --- JTB generated node declarations ---
  AST::MultiplicativeExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeChoice<R, A...>* n2 = null;
  AST::NodeSequence<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
  AST::MultiplicativeExpression<R, A...>* n6 = null;
  AST::NodeSequence<R, A...>* n7 = null;
  AST::NodeToken<R, A...>* n8 = null;
  Token* n9 = null;
  AST::MultiplicativeExpression<R, A...>* n10 = null;
}
{
  n0 =  MultiplicativeExpression<R, A...>()
  (
    (
      { n3 = new AST::NodeSequence<R, A...>(2); }
      n5 = "+"
      { n4 = makeNodeToken<R, A...>(n5); }
      { n3->addNode(n4); }
      n6 =  MultiplicativeExpression<R, A...>()
      { n3->addNode(n6); }
      { n2 = new AST::NodeChoice<R, A...>(n3, 0, 2); }
    |
      { n7 = new AST::NodeSequence<R, A...>(2); }
      n9 = "-"
      { n8 = makeNodeToken<R, A...>(n9); }
      { n7->addNode(n8); }
      n10 =  MultiplicativeExpression<R, A...>()
      { n7->addNode(n10); }
      { n2 = new AST::NodeChoice<R, A...>(n7, 1, 2); }
    )
    { n1->addNode(n2); }
  )*
  { return new AST::AdditiveExpression<R, A...>(n0, n1); }
}

/** Multiplicative expression. */
template<typename R, typename ... A>
AST::MultiplicativeExpression<R, A...>* MultiplicativeExpression() :
{
  // --- JTB generated node declarations ---
  AST::UnaryExpression<R, A...>* n0 = null;
  AST::NodeListOptional<R, A...>* n1 = new AST::NodeListOptional<R, A...>();
  AST::NodeChoice<R, A...>* n2 = null;
  AST::NodeSequence<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
  AST::UnaryExpression<R, A...>* n6 = null;
  AST::NodeSequence<R, A...>* n7 = null;
  AST::NodeToken<R, A...>* n8 = null;
  Token* n9 = null;
  AST::UnaryExpression<R, A...>* n10 = null;
  AST::NodeSequence<R, A...>* n11 = null;
  AST::NodeToken<R, A...>* n12 = null;
  Token* n13 = null;
  AST::UnaryExpression<R, A...>* n14 = null;
}
{
  n0 =  UnaryExpression<R, A...>()
  (
    (
      { n3 = new AST::NodeSequence<R, A...>(2); }
      n5 = "*"
      { n4 = makeNodeToken<R, A...>(n5); }
      { n3->addNode(n4); }
      n6 =  UnaryExpression<R, A...>()
      { n3->addNode(n6); }
      { n2 = new AST::NodeChoice<R, A...>(n3, 0, 3); }
    |
      { n7 = new AST::NodeSequence<R, A...>(2); }
      n9 = "/"
      { n8 = makeNodeToken<R, A...>(n9); }
      { n7->addNode(n8); }
      n10 =  UnaryExpression<R, A...>()
      { n7->addNode(n10); }
      { n2 = new AST::NodeChoice<R, A...>(n7, 1, 3); }
    |
      { n11 = new AST::NodeSequence<R, A...>(2); }
      n13 = "%"
      { n12 = makeNodeToken<R, A...>(n13); }
      { n11->addNode(n12); }
      n14 =  UnaryExpression<R, A...>()
      { n11->addNode(n14); }
      { n2 = new AST::NodeChoice<R, A...>(n11, 2, 3); }
    )
    { n1->addNode(n2); }
  )*
  { return new AST::MultiplicativeExpression<R, A...>(n0, n1); }
}

/** Unary expression. */
template<typename R, typename ... A>
AST::UnaryExpression<R, A...>* UnaryExpression() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::NodeSequence<R, A...>* n1 = null;
  AST::NodeToken<R, A...>* n2 = null;
  Token* n3 = null;
  AST::UnaryExpression<R, A...>* n4 = null;
  AST::NodeSequence<R, A...>* n5 = null;
  AST::NodeToken<R, A...>* n6 = null;
  Token* n7 = null;
  AST::UnaryExpression<R, A...>* n8 = null;
  AST::PrimaryExpression<R, A...>* n9 = null;
}
{
  (
    { n1 = new AST::NodeSequence<R, A...>(2); }
    n3 = "~"
    { n2 = makeNodeToken<R, A...>(n3); }
    { n1->addNode(n2); }
    n4 =  UnaryExpression<R, A...>()
    { n1->addNode(n4); }
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 3); }
  |
    { n5 = new AST::NodeSequence<R, A...>(2); }
    n7 = "!"
    { n6 = makeNodeToken<R, A...>(n7); }
    { n5->addNode(n6); }
    n8 =  UnaryExpression<R, A...>()
    { n5->addNode(n8); }
    { n0 = new AST::NodeChoice<R, A...>(n5, 1, 3); }
  |
    n9 =  PrimaryExpression<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n9, 2, 3); }
  )
  { return new AST::UnaryExpression<R, A...>(n0); }
}

/** Primary expression. */
template<typename R, typename ... A>
AST::PrimaryExpression<R, A...>* PrimaryExpression() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::Literal<R, A...>* n1 = null;
  AST::Id<R, A...>* n2 = null;
  AST::NodeSequence<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
  AST::Expression<R, A...>* n6 = null;
  AST::NodeToken<R, A...>* n7 = null;
  Token* n8 = null;
  // --- user BNFProduction java block ---
  String name;
}
{
  (
    n1 =  Literal<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 3); }
  |
    n2 =  Id<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n2, 1, 3); }
  |
    { n3 = new AST::NodeSequence<R, A...>(3); }
    n5 = "("
    { n4 = makeNodeToken<R, A...>(n5); }
    { n3->addNode(n4); }
    n6 =  Expression<R, A...>()
    { n3->addNode(n6); }
    n8 = ")"
    { n7 = makeNodeToken<R, A...>(n8); }
    { n3->addNode(n7); }
    { n0 = new AST::NodeChoice<R, A...>(n3, 2, 3); }
  )
  { return new AST::PrimaryExpression<R, A...>(n0); }
}

/** An Id. */
template<typename R, typename ... A>
AST::Id<R, A...>* Id() :
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
}
{
  n1 = < IDENTIFIER >
  { n0 = makeNodeToken<R, A...>(n1); }
  { return new AST::Id<R, A...>(n0); }
}

/** A literal. */
template<typename R, typename ... A>
AST::Literal<R, A...>* Literal() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::NodeToken<R, A...>* n1 = null;
  Token* n2 = null;
  AST::BooleanLiteral<R, A...>* n3 = null;
}
{
  (
    n2 = < INTEGER_LITERAL >
    { n1 = makeNodeToken<R, A...>(n2); }
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 2); }
  |
    n3 =  BooleanLiteral<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n3, 1, 2); }
  )
  { return new AST::Literal<R, A...>(n0); }
}

/** A boolean literal. */
template<typename R, typename ... A>
AST::BooleanLiteral<R, A...>* BooleanLiteral() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::NodeToken<R, A...>* n1 = null;
  Token* n2 = null;
  AST::NodeToken<R, A...>* n3 = null;
  Token* n4 = null;
}
{
  (
    n2 = "true"
    { n1 = makeNodeToken<R, A...>(n2); }
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 2); }
  |
    n4 = "false"
    { n3 = makeNodeToken<R, A...>(n4); }
    { n0 = new AST::NodeChoice<R, A...>(n3, 1, 2); }
  )
  { return new AST::BooleanLiteral<R, A...>(n0); }
}

/*
 * Statement syntax follows.
 */
/** A statement. */
template<typename R, typename ... A>
AST::Statement<R, A...>* Statement() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::NodeToken<R, A...>* n1 = null;
  Token* n2 = null;
  AST::LabeledStatement<R, A...>* n3 = null;
  AST::Block<R, A...>* n4 = null;
  AST::StatementExpression<R, A...>* n5 = null;
  AST::IfStatement<R, A...>* n6 = null;
  AST::WhileStatement<R, A...>* n7 = null;
  AST::IOStatement<R, A...>* n8 = null;
}
{
  (
    n2 = ";"
    { n1 = makeNodeToken<R, A...>(n2); }
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 7); }
  |
    LOOKAHEAD( 2 )
    n3 =  LabeledStatement<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n3, 1, 7); }
  |
    n4 =  Block<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n4, 2, 7); }
  |
    n5 =  StatementExpression<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n5, 3, 7); }
  |
    n6 =  IfStatement<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n6, 4, 7); }
  |
    n7 =  WhileStatement<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n7, 5, 7); }
  |
    n8 =  IOStatement<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n8, 6, 7); }
  )
  { return new AST::Statement<R, A...>(n0); }
}

/** A labeled statement. */
template<typename R, typename ... A>
AST::LabeledStatement<R, A...>* LabeledStatement() :
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
  AST::NodeToken<R, A...>* n2 = null;
  Token* n3 = null;
  AST::Statement<R, A...>* n4 = null;
}
{
  n1 = < IDENTIFIER >
  { n0 = makeNodeToken<R, A...>(n1); }
  n3 = ":"
  { n2 = makeNodeToken<R, A...>(n3); }
  n4 =  Statement<R, A...>()
  { return new AST::LabeledStatement<R, A...>(n0, n2, n4); }
}

/** A block. */
template<typename R, typename ... A>
AST::Block<R, A...>* Block() :
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
  AST::NodeListOptional<R, A...>* n2 = new AST::NodeListOptional<R, A...>();
  AST::Statement<R, A...>* n3 = null;
  AST::NodeToken<R, A...>* n4 = null;
  Token* n5 = null;
}
{
  n1 = "{"
  { n0 = makeNodeToken<R, A...>(n1); }
  (
    n3 =  Statement<R, A...>()
    { n2->addNode(n3); }
  )*
  n5 = "}"
  { n4 = makeNodeToken<R, A...>(n5); }
  { return new AST::Block<R, A...>(n0, n2, n4); }
}

/** A statement expression. */
template<typename R, typename ... A>
AST::StatementExpression<R, A...>* StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * SPL expansions for StatementExpression.
 */
{
  // --- JTB generated node declarations ---
  AST::Assignment<R, A...>* n0 = null;
  AST::NodeToken<R, A...>* n1 = null;
  Token* n2 = null;
}
{
  n0 =  Assignment<R, A...>()
  n2 = ";"
  { n1 = makeNodeToken<R, A...>(n2); }
  { return new AST::StatementExpression<R, A...>(n0, n1); }
}

/** An if statement. */
template<typename R, typename ... A>
AST::IfStatement<R, A...>* IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
  AST::NodeToken<R, A...>* n2 = null;
  Token* n3 = null;
  AST::Expression<R, A...>* n4 = null;
  AST::NodeToken<R, A...>* n5 = null;
  Token* n6 = null;
  AST::Statement<R, A...>* n7 = null;
  AST::NodeOptional<R, A...>* n8 = new AST::NodeOptional<R, A...>();
  AST::NodeSequence<R, A...>* n9 = null;
  AST::NodeToken<R, A...>* n10 = null;
  Token* n11 = null;
  AST::Statement<R, A...>* n12 = null;
}
{
  n1 = "if"
  { n0 = makeNodeToken<R, A...>(n1); }
  n3 = "("
  { n2 = makeNodeToken<R, A...>(n3); }
  n4 =  Expression<R, A...>()
  n6 = ")"
  { n5 = makeNodeToken<R, A...>(n6); }
  n7 =  Statement<R, A...>()
  [
    LOOKAHEAD( 1 )
    { n9 = new AST::NodeSequence<R, A...>(2); }
    n11 = "else"
    { n10 = makeNodeToken<R, A...>(n11); }
    { n9->addNode(n10); }
    n12 =  Statement<R, A...>()
    { n9->addNode(n12); }
    { n8->addNode(n9); }
  ]
  { return new AST::IfStatement<R, A...>(n0, n2, n4, n5, n7, n8); }
}

/** A while statement. */
template<typename R, typename ... A>
AST::WhileStatement<R, A...>* WhileStatement() :
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
  AST::NodeToken<R, A...>* n2 = null;
  Token* n3 = null;
  AST::Expression<R, A...>* n4 = null;
  AST::NodeToken<R, A...>* n5 = null;
  Token* n6 = null;
  AST::Statement<R, A...>* n7 = null;
}
{
  n1 = "while"
  { n0 = makeNodeToken<R, A...>(n1); }
  n3 = "("
  { n2 = makeNodeToken<R, A...>(n3); }
  n4 =  Expression<R, A...>()
  n6 = ")"
  { n5 = makeNodeToken<R, A...>(n6); }
  n7 =  Statement<R, A...>()
  { return new AST::WhileStatement<R, A...>(n0, n2, n4, n5, n7); }
}

/** An IO statement. */
template<typename R, typename ... A>
AST::IOStatement<R, A...>* IOStatement() :
{
  // --- JTB generated node declarations ---
  AST::NodeChoice<R, A...>* n0 = null;
  AST::ReadStatement<R, A...>* n1 = null;
  AST::WriteStatement<R, A...>* n2 = null;
  // --- user BNFProduction java block ---
  String name;
}
{
  (
    n1 =  ReadStatement<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n1, 0, 2); }
  |
    n2 =  WriteStatement<R, A...>()
    { n0 = new AST::NodeChoice<R, A...>(n2, 1, 2); }
  )
  { return new AST::IOStatement<R, A...>(n0); }
}

/** A read statement. */
template<typename R, typename ... A>
AST::ReadStatement<R, A...>* ReadStatement() :
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
  AST::NodeToken<R, A...>* n2 = null;
  Token* n3 = null;
}
{
  n1 = "read"
  { n0 = makeNodeToken<R, A...>(n1); }
  n3 = < IDENTIFIER >
  { n2 = makeNodeToken<R, A...>(n3); }
  { return new AST::ReadStatement<R, A...>(n0, n2); }
}

/** A write statement. */
template<typename R, typename ... A>
AST::WriteStatement<R, A...>* WriteStatement() :
{
  // --- JTB generated node declarations ---
  AST::NodeToken<R, A...>* n0 = null;
  Token* n1 = null;
  AST::NodeToken<R, A...>* n2 = null;
  Token* n3 = null;
}
{
  n1 = "write"
  { n0 = makeNodeToken<R, A...>(n1); }
  n3 = < IDENTIFIER >
  { n2 = makeNodeToken<R, A...>(n3); }
  { return new AST::WriteStatement<R, A...>(n0, n2); }
}

TOKEN :
/* IDENTIFIERS */
{
  < IDENTIFIER : <LETTER> ( <LETTER>| <DIGIT> )* >
| < #LETTER : ["a"-"z", "A"-"Z"] >
| < #DIGIT : ["0"-"9"] >
}
